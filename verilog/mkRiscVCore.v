//
// Generated by Bluespec Compiler, version 2025.01.1 (build 65e3a87a)
//
// On Sat Jun  7 18:52:24 UTC 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_iCache_req                 O     1 const
// iCache_resp                    O    64 const
// RDY_iCache_resp                O     1 const
// RDY_dCache_req                 O     1 const
// dCache_resp                    O    64 const
// RDY_dCache_resp                O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// iCache_req_addr                I    64 unused
// iCache_req_data                I    64 unused
// iCache_req_write               I     1 unused
// dCache_req_addr                I    64 unused
// dCache_req_data                I    64 unused
// dCache_req_write               I     1 unused
// EN_iCache_req                  I     1 unused
// EN_dCache_req                  I     1 unused
// EN_iCache_resp                 I     1 unused
// EN_dCache_resp                 I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkRiscVCore(CLK,
		   RST_N,

		   iCache_req_addr,
		   iCache_req_data,
		   iCache_req_write,
		   EN_iCache_req,
		   RDY_iCache_req,

		   EN_iCache_resp,
		   iCache_resp,
		   RDY_iCache_resp,

		   dCache_req_addr,
		   dCache_req_data,
		   dCache_req_write,
		   EN_dCache_req,
		   RDY_dCache_req,

		   EN_dCache_resp,
		   dCache_resp,
		   RDY_dCache_resp);
  input  CLK;
  input  RST_N;

  // action method iCache_req
  input  [63 : 0] iCache_req_addr;
  input  [63 : 0] iCache_req_data;
  input  iCache_req_write;
  input  EN_iCache_req;
  output RDY_iCache_req;

  // actionvalue method iCache_resp
  input  EN_iCache_resp;
  output [63 : 0] iCache_resp;
  output RDY_iCache_resp;

  // action method dCache_req
  input  [63 : 0] dCache_req_addr;
  input  [63 : 0] dCache_req_data;
  input  dCache_req_write;
  input  EN_dCache_req;
  output RDY_dCache_req;

  // actionvalue method dCache_resp
  input  EN_dCache_resp;
  output [63 : 0] dCache_resp;
  output RDY_dCache_resp;

  // signals for module outputs
  wire [63 : 0] dCache_resp, iCache_resp;
  wire RDY_dCache_req, RDY_dCache_resp, RDY_iCache_req, RDY_iCache_resp;

  // register pc
  reg [63 : 0] pc;
  wire [63 : 0] pc$D_IN;
  wire pc$EN;

  // register stage1
  reg stage1;
  wire stage1$D_IN, stage1$EN;

  // register stage2
  reg stage2;
  wire stage2$D_IN, stage2$EN;

  // action method iCache_req
  assign RDY_iCache_req = 1'd1 ;

  // actionvalue method iCache_resp
  assign iCache_resp = 64'd0 ;
  assign RDY_iCache_resp = 1'd1 ;

  // action method dCache_req
  assign RDY_dCache_req = 1'd1 ;

  // actionvalue method dCache_resp
  assign dCache_resp = 64'd0 ;
  assign RDY_dCache_resp = 1'd1 ;

  // register pc
  assign pc$D_IN = 64'h0 ;
  assign pc$EN = 1'b0 ;

  // register stage1
  assign stage1$D_IN = 1'b0 ;
  assign stage1$EN = 1'b0 ;

  // register stage2
  assign stage2$D_IN = 1'b0 ;
  assign stage2$EN = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        pc <= `BSV_ASSIGNMENT_DELAY 64'd0;
	stage1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	stage2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (pc$EN) pc <= `BSV_ASSIGNMENT_DELAY pc$D_IN;
	if (stage1$EN) stage1 <= `BSV_ASSIGNMENT_DELAY stage1$D_IN;
	if (stage2$EN) stage2 <= `BSV_ASSIGNMENT_DELAY stage2$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    pc = 64'hAAAAAAAAAAAAAAAA;
    stage1 = 1'h0;
    stage2 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkRiscVCore

